\documentclass{article}

\title{Manipulator rigid-body dynamics}
\author{Peter Corke}
\date{1996}

\usepackage{epsfig}
\usepackage{amsmath}
\input{pic-common}

\usepackage{xifthen}
\renewcommand{\vec}[2][ZZZZ]{\ifthenelse{\equal{#1}{ZZZZ}}{}{\,{}^{#1}}{\bf #2}}
\newcommand{\dvec}[2][ZZZZ]{\ifthenelse{\equal{#1}{ZZZZ}}{}{\,{}^{#1}}{\dot{\bf #2}}}
\newcommand{\ddvec}[2][ZZZZ]{\ifthenelse{\equal{#1}{ZZZZ}}{}{\,{}^{#1}}{\ddot{\bf #2}}}
\newcommand{\veco}[2][ZZZZ]{\ifthenelse{\equal{#1}{ZZZZ}}{}{\,{}^{#1}}{\overline{#2}}}
\newcommand{\dveco}[2][ZZZZ]{\ifthenelse{\equal{#1}{ZZZZ}}{}{\,{}^{#1}}{\dot{\overline #2}}}

\newcommand{\vech}[2][ZZZZ]{\ifthenelse{\equal{#1}{ZZZZ}}{}{\,{}^{#1}}{\tilde{#2}}}
\newcommand{\vect}[2][ZZZZ]{\ifthenelse{\equal{#1}{ZZZZ}}{}{\,{}^{#1}}{\hat{#2}}}
\newcommand{\vecb}[2][ZZZZ]{\ifthenelse{\equal{#1}{ZZZZ}}{}{\,{}^{#1}}{\bar{\underline #2}}}

\newcommand{\mat}[2][ZZZZ]{\ifthenelse{\equal{#1}{ZZZZ}}{}{\,{}^{#1}}{{#2}}}


\begin{document}
\maketitle
%%%%%%%%%%%%% RIGID-BODY DYNAMICS%%%%%%%%%%%%%%%

\section{Introduction}  \label{sec:robot-rigid-body}
Manipulator dynamics is concerned with the equations of motion, the way
in which the manipulator moves in response to torques applied by the actuators,
or external forces.
The history and mathematics of the dynamics of serial-link
manipulators is well covered by Paul\cite{Paul81a} and
Hollerbach\cite{Hollerbach82}.
There are two problems related to manipulator dynamics that are important to solve:
\begin{itemize}
\item \DEF{inverse dynamics} in which the manipulator's equations of motion  are
solved for given motion to determine the generalized forces, discussed further in
Section \ref{sec:robot-control}, and
\item \DEF{direct dynamics} in which the equations of motion are integrated to determine
the generalized coordinate response to applied generalized forces discussed further
in Section \ref{robot:direct-dyn}.
\end{itemize}
The equations of motion for an $N$-axis manipulator are given by
\begin{align}
\vec{Q} &=
\mat{M}\left(\vec{q}\right)\ddvec{q} + \mat{C}\left(\vec{q},\ddot{q}\right) \ddot{q} +
\vec{F}\left(\dvec{q}\right) + \vec{g}\left(\vec{q}\right) \label{eq:inv-dyn}
\end{align}
where

\begin{tabular}{r p{4in}}
$\vec{q}$ & N-vector of generalized joint coordinates describing
the pose of the manipulator\\
$\dvec{q}$ & N-vector of joint velocities;      \\
$\ddvec{q}$ & N-vector of joint accelerations   \\
$\mat{M}$ & joint-space inertia, $N \times N$ symmetric  matrix, or manipulator inertia
tensor\\
$\mat{C}$ & Coriolis and centripetal term --- Centripetal torques are
proportional to $\dot{q}_i^2$, while the Coriolis torques are proportional
to $\dot{q}_i \dot{q}_j$\\
$\vec{F}$ & friction, viscous and Coulomb, and not generally considered
part of the rigid-body dynamics\\
$\vec{g}$ & gravity loading\\
$\vec{Q}$ & N-vector of generalized forces associated with the
generalized coordinates $\vec{q}$.
\end{tabular}


\section{Recursive Newton-Euler formulation}
The recursive Newton-Euler (RNE) formulation\cite{Luh80a}
computes the inverse manipulator dynamics, that is, the joint torques
required for a given set of joint angles, velocities and accelerations.
The forward recursion propagates kinematic information --- such as
angular velocities, angular accelerations, linear accelerations --- from the base
reference frame (inertial frame) to the end-effector.  The backward
recursion propagates the forces and moments exerted on each link from
the end-effector of the manipulator to the base reference frame\footnote{It 
should be noted that using MDH notation with its different
axis assignment conventions the Newton Euler formulation is expressed
differently\cite{Craig89}.}.
Figure \ref{fig:dynamics-notation} shows the variables involved in the
computation for one link.

The notation of Hollerbach\cite{Hollerbach80} and Walker and Orin
\cite{Walker82} will be used in
which the left superscript indicates the reference coordinate
frame for the variable.  The notation of Luh \etal\cite{Luh80a}
and later Lee\cite{Lee82a,Fu87} is considerably less clear.

\begin{figure}
\centerline{\epsfig{figure=dyn.eps,width=\textwidth}}


\begin{tabular}{r p{12cm}}
$i$ &  link index, in the range $1$ to $n$ \\
$\mat{J}_i$ &  moment of inertia of link $i$ about its COM\\
$\vec{s}_i$ &  position vector of the COM of link $i$ with respect to
frame $i$\\
$\vec{\omega}_i$ &  angular velocity of link $i$\\
$\dvec{\omega}_i$ &  angular acceleration of link $i$\\
$\vec{v}_i$ &  linear velocity of frame $i$\\
$\dvec{v}_i$ &  linear acceleration of frame $i$\\
$\veco{v}_i$ &  linear velocity of the COM of link $i$ \\
$\dveco{v}_i$ &  linear acceleration of the COM of link
$i$ \\
$\vec{n}_i$ &  moment exerted on link $i$ by link $i-1$ \\
$\vec{f}_i$ &  force exerted on link $i$ by link $i-1$ \\
$\vec{N}_i$ &  total moment at the COM of link $i$\\
$\vec{F}_i$ &  total force at the COM of link $i$ \\
$\vec{Q}_i$ &  force or torque exerted by the actuator at joint $i$\\
$\mat[i-i]{R}_i$ &  orthonormal rotation matrix defining
frame $i$ orientation with respect to frame $i-1$.  It  upper $3 \times
3$
portion of the link transform matrix 
\begin{eqnarray}
\mat[i-1]{R}_i &=&  \begin{bmatrix}
 \cos \theta_i & -\cos \alpha_i \sin \theta_i & \sin \alpha_i \sin \theta_i \\
 \sin \theta_i & \cos \alpha_i \cos \theta_i & -\sin \alpha_i \cos \theta_i \\
 0             & \sin \alpha_i               & \cos \alpha_i
 \end{bmatrix} \\
\mat[i]{R}_{i-1} &=& ( \mat[i-1]{R}_{i} ) ^{-1} = ( \mat[i-1]{R}_{i} ) ^T
\end{eqnarray}
\\
$\vec[i]{p}_i$ &  displacement from the origin of frame $i-1$
to frame $i$ with respect to frame $i$.  Often denoted $\vec{p}_i$ in source papers.
\begin{equation}
\vec[i]{p}_i = \begin{bmatrix}
	a_i \\
	d_i \sin \alpha_i \\
	d_i \cos \alpha_i
	\end{bmatrix}
\end{equation}
It is the negative translational part of $(\mat[i-1]{A}_{i})^{-1}$.\\
$\vec{z}_0$ & is a unit vector in Z direction, $\vec{z}_0 = [0\;0\;1]$ \\
\end{tabular}

\caption{Notation for
recursive Newton-Euler inverse dynamics, based on standard Denavit-Hartenberg notation.
Variables in C and Matlab implementation
have the same names.}
\end{figure}

\paragraph{Outward recursion, $1\leq i\leq n$.}

\begin{align}
\intertext{If axis $i+1$ is rotational}
\vec[i+1]{\omega}_{i+1} & = 
	\mat[i+1]{R}_i \left( \vec[i]{\omega}_i + \vec{z}_0\dot{\vec{q}}_{i+1} \right)	\label{eq:rne-start}
	\\
\dvec[i+1]{\omega}_{i+1}  & = 
	\mat[i+1]{R}_i \left\{ {}^i\dot{\vec{\omega}}_i +
	\vec{z}_0\ddot{\vec{q}}_{i+1} +
	\vec[i]{\omega}_i \times \left(\vec{z}_0\dot{\vec{q}}_{i+1}\right)\right\}                    \\
\vec[i+1]{v}_{i+1} & = 
	\vec[i+1]{\omega}_{i+1} \times  \vec[i+1]{p}_{i+1} +
	\mat[i+1]{R}_i \vec[i]{v}_i
	\label{eq:v-rot}                        \\
\dvec[i+1]{v}_{i+1} & = 
	\dvec[i+1]{\omega}_{i+1} \times \vec[i+1]{p}_{i+1} +
	\vec[i+1]{\omega}_{i+1} \times \left\{
	    \vec[i+1]{\omega}_{i+1} \times  \vec[i+1]{p}_{i+1}
	\right\} + \mat[i+1]{R}_i {}^i\dot{\vec{v}}_i
	\\
\intertext{If axis $i+1$ is translational}
\vec[i+1]{\omega}_{i+1} & = 
	\mat[i+1]{R}_i \vec[i]{\omega}_i
	\\
\dvec[i+1]{\omega}_{i+1}  & = 
	\mat[i+1]{R}_i  {}^i\dot{\vec{\omega}}_i
	\\
\vec[i+1]{v}_{i+1} & = 
	\mat[i+1]{R}_i \left(\vec{z}_0\dot{\vec{q}}_{i+1} + \vec[i]{v}_i\right) +
	\vec[i+1]{\omega}_{i+1} \times \vec[i+1]{p}_{i+1}
	\label{eq:v-trans}                       \\
\dvec[i+1]{v}_{i+1} & = 
	\mat[i+1]{R}_i \left(\vec{z}_0 \ddot{\vec{q}}_{i+1} + {}^i\dot{\vec{v}}_i\right) +
	\dvec[i+1]{\omega}_{i+1} \times \vec[i+1]{p}_{i+1} + \\
	& 2\; \vec[i+1]{\omega}_{i+1}  \times \left(\mat[i+1]{R}_i \vec{z}_0
	\dot{\vec{q}}_{i+1}\right)	 + \vec[i+1]{\omega}_{i+1} \times \left(
		\vec[i+1]{\omega}_{i+1} \times \vec[i+1]{p}_{i+1}\right) \\
{}^i\dot{\vec{\overline{v}}}_i & = 
	{}^i\dot{\vec{\omega}}_i \times \vec{s}_i +
	\vec[i]{\omega}_i \times \left\{
		\vec[i]{\omega}_i \times \vec{s}_i
	\right\} +
	{}^i\dot{\vec{v}}_i \label{eq:rne-vbar}\\
\vec[i]{F}_i & =  m_i {}^i\dot{\vec{\overline{v}}}_i \label{eq:rne-Fi}\\
\vec[i]{N}_i & = 
	{\bf J}_i  {}^i\dot{\vec{\omega}}_i +
	\vec[i]{\omega}_i \times \left({\bf J}_i \vec[i]{\omega}_i\right)
\end{align}
Note that the COM linear velocity given by equation (\ref{eq:v-rot}) or
(\ref{eq:v-trans}) does not need to be computed since no other
expression depends upon it.

Boundary conditions are used to introduce the effect of gravity by setting the
acceleration of the base link
\be
\dot{v}_0 = -\vec{g}
\ee
where $\vec{g}$ is the gravity vector in the reference coordinate 
frame, generally acting in the negative Z direction, downward.
Base velocity is generally zero
\begin{eqnarray}
v_0 &=& 0       \\
\omega_0 &=& 0 \\
\dot{\omega}_0 &=& 0
\end{eqnarray}

\paragraph{Inward recursion, $n \geq i \geq 1$.}
\begin{align}
\vec[i]{f}_i  & =
	\mat[i]{R}_{i+1}\,  \vec[i+1]{f}_{i+1} + \vec[i]{F}_i \label{eq:rne-fi}\\
\vec[i]{n}_i & =
	\mat[i]{R}_{i+1} \, \left\{ \vec[i+1]{n}_{i+1} +
	\left( \mat[i+1]{R}_i \vec[i]{p}_i \right) \times {}^i \vec[i+1]{f}_{i+1}\right\} +
	\left(\vec[i]{p}_i + \vec{s}_i\right) \times \vec[i]{F}_i +
	\vec[i]{N}_i  \label{eq:rne-ni} \\
\vec{Q}_i & =  \left\{ \begin{array}{ll}
	\left(\vec[i]{n}_i\right)^T \left(\mat[i]{R}_{i+1} \vec{z}_0\right) &
		\mbox{if link $i+1$ is rotational} \\
	\left(\vec[i]{f}_i\right)^T \left(\mat[i]{R}_{i+1} \vec{z}_0\right)&
		\mbox{if link $i+1$ is translational}
	\end{array} \right.				\label{eq:rne-end}
\end{align}

At each step the wrench, $[\vec{f}_i ,\, \vec{n}_i]$ mutually exerted on link $i$ by link $i+1$ is computed.
An external force on the last frame of the manipulator is introduced as $[\vec{f}_n ,\, \vec{n}_n]$.
The base force, exerted by the ground on the robot's first link can be computed as 
$[\vec{f}_0 ,\, \vec{n}_0]$ by extending the iteration, equations \eq{eq:rne-fi} and \eq{eq:rne-ni},
and setting the rotation matrix to unity.


\section{Rigid-body inertial parameters} \label{sec:robot-rigidbody-params}
Accurate model-based dynamic control of a manipulator requires knowledge of the
rigid-body inertial parameters.
Each link has ten independent  inertial parameters:
\begin{itemize}
\item link mass, $m_i$;
\item three first moments, which may be expressed
as the COM location, $\vec{s}_i$, with respect to some datum on the link
or as a moment $\vec{S}_i = m_i \vec{s}_i$;
\item six second moments, which represent the inertia of the link about a
given axis, typically through the COM.
The second moments may be expressed in matrix or tensor form as
\be
{\bf J} = \left[ \begin{array}{ccc}
		J_{xx} & J_{xy} & J_{xz}\\
		J_{xy} & J_{yy} & J_{yz}\\
		J_{xz} & J_{yz} & J_{zz}
	   \end{array}
	\right]		\label{eq:inertia-matrix}
\ee
where the diagonal elements are the \DEF{moments of inertia}, and the
off-diagonals are \DEF{products of inertia}.
Only six of these nine elements are unique:
three moments and three products of inertia.

For any point in a rigid-body there is one set of axes known as the
\DEF{principal axes of inertia} for which the off-diagonal terms, or products, are
zero.  These axes are given by the eigenvectors of the
inertia matrix \eq{eq:inertia-matrix} and the eigenvalues are the principal moments of
inertia.  Frequently the products of inertia of the robot links are zero due 
to symmetry.
\end{itemize}

A 6-axis manipulator rigid-body dynamic model thus entails 60 
inertial parameters.
There may be additional parameters per joint due to friction and motor 
armature inertia.  
Clearly, establishing numeric values for this number of parameters is a difficult task.
Many parameters cannot be measured without dismantling the robot and performing
careful experiments, though this approach was used by Armstrong \etal\cite{Armstrong86}.
Most parameters could be derived from CAD models of the robots, but this information
is often considered proprietary and not made available to researchers.
The robot used in this work, the Puma 560, was designed in the late 1970's and 
probably predates widespread CAD usage.
A discussion of manipulator parameter estimation techniques and experiments
is deferred until Section \ref{sec:robot-param-ident} in order to cover the
prerequisites of friction modeling and motor parameters introduced in the
next section.



\end{document}
