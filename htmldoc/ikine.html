<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of ikine</title>
  <meta name="keywords" content="ikine">
  <meta name="description" content="IKINE Inverse manipulator kinematics">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="./m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="./index.html">Home</a> &gt;  <a href="index.html">.</a> &gt; ikine.m</div>

<!--<table width="100%"><tr><td align="left"><a href="./index.html"><img alt="<" border="0" src="./left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for .&nbsp;<img alt=">" border="0" src="./right.png"></a></td></tr></table>-->

<h1>ikine
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="./up.png"></a></h2>
<div class="box"><strong>IKINE Inverse manipulator kinematics</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="./up.png"></a></h2>
<div class="box"><strong>function qt = ikine(robot, tr, q, m) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="./up.png"></a></h2>
<div class="fragment"><pre class="comment">IKINE Inverse manipulator kinematics

    Q = IKINE(ROBOT, T)
    Q = IKINE(ROBOT, T, Q)
    Q = IKINE(ROBOT, T, Q, M)

 Returns the joint coordinates corresponding to the end-effector transform T.
 Note that the inverse kinematic solution is generally not unique, and 
 depends on the initial guess Q (which defaults to 0).

    QT = IKINE(ROBOT, TG)
    QT = IKINE(ROBOT, TG, Q)
    QT = IKINE(ROBOT, TG, Q, M)

 Returns the joint coordinates corresponding to each of the transforms in 
 the 4x4xN trajectory TG.
 Returns one row of QT for each input transform.  The initial estimate 
 of QT for each time step is taken as the solution from the previous 
 time step.

 If the manipulator has fewer than 6 DOF then this method of solution
 will fail, since the solution space has more dimensions than can
 be spanned by the manipulator joint coordinates.  In such a case
 it is necessary to provide a mask matrix, M, which specifies the 
 Cartesian DOF (in the wrist coordinate frame) that will be ignored
 in reaching a solution.  The mask matrix has six elements that
 correspond to translation in X, Y and Z, and rotation about X, Y and
 Z respectively.  The value should be 0 (for ignore) or 1.  The number
 of non-zero elements should equal the number of manipulator DOF.

 Solution is computed iteratively using the pseudo-inverse of the
 manipulator Jacobian.

 Such a solution is completely general, though much less efficient 
 than specific inverse kinematic solutions derived symbolically.
 
 This approach allows a solution to obtained at a singularity, but 
 the joint angles within the null space are arbitrarily assigned.

 For instance with a typical 5 DOF manipulator one would ignore
 rotation about the wrist axis, that is, M = [1 1 1 1 1 0].


 See also: <a href="fkine.html" class="code" title="function t = fkine(robot, q)">FKINE</a>, <a href="tr2diff.html" class="code" title="function d = tr2diff(t1, t2)">TR2DIFF</a>, <a href="jacob0.html" class="code" title="function J0 = jacob0(robot, q)">JACOB0</a>, <a href="ikine560.html" class="code" title="function theta = ikine560(robot, T,configuration)">IKINE560</a>.</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="./up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(./matlabicon.gif)">
<li><a href="fkine.html" class="code" title="function t = fkine(robot, q)">fkine</a>	FKINE  Forward robot kinematics for serial link manipulator</li><li><a href="ishomog.html" class="code" title="function h = ishomog(tr)">ishomog</a>	ISHOMOG Test if argument is a homogeneous transformation</li><li><a href="jacob0.html" class="code" title="function J0 = jacob0(robot, q)">jacob0</a>	JACOB0 Compute manipulator Jacobian in world coordinates</li><li><a href="tr2diff.html" class="code" title="function d = tr2diff(t1, t2)">tr2diff</a>	TR2DIFF Convert a transform difference to differential representation</li></ul>
This function is called by:
<ul style="list-style-image:url(./matlabicon.gif)">
</ul>
<!-- crossreference -->


<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="./up.png"></a></h2>
<div class="fragment"><pre>0001 <span class="comment">%IKINE Inverse manipulator kinematics</span>
0002 <span class="comment">%</span>
0003 <span class="comment">%    Q = IKINE(ROBOT, T)</span>
0004 <span class="comment">%    Q = IKINE(ROBOT, T, Q)</span>
0005 <span class="comment">%    Q = IKINE(ROBOT, T, Q, M)</span>
0006 <span class="comment">%</span>
0007 <span class="comment">% Returns the joint coordinates corresponding to the end-effector transform T.</span>
0008 <span class="comment">% Note that the inverse kinematic solution is generally not unique, and</span>
0009 <span class="comment">% depends on the initial guess Q (which defaults to 0).</span>
0010 <span class="comment">%</span>
0011 <span class="comment">%    QT = IKINE(ROBOT, TG)</span>
0012 <span class="comment">%    QT = IKINE(ROBOT, TG, Q)</span>
0013 <span class="comment">%    QT = IKINE(ROBOT, TG, Q, M)</span>
0014 <span class="comment">%</span>
0015 <span class="comment">% Returns the joint coordinates corresponding to each of the transforms in</span>
0016 <span class="comment">% the 4x4xN trajectory TG.</span>
0017 <span class="comment">% Returns one row of QT for each input transform.  The initial estimate</span>
0018 <span class="comment">% of QT for each time step is taken as the solution from the previous</span>
0019 <span class="comment">% time step.</span>
0020 <span class="comment">%</span>
0021 <span class="comment">% If the manipulator has fewer than 6 DOF then this method of solution</span>
0022 <span class="comment">% will fail, since the solution space has more dimensions than can</span>
0023 <span class="comment">% be spanned by the manipulator joint coordinates.  In such a case</span>
0024 <span class="comment">% it is necessary to provide a mask matrix, M, which specifies the</span>
0025 <span class="comment">% Cartesian DOF (in the wrist coordinate frame) that will be ignored</span>
0026 <span class="comment">% in reaching a solution.  The mask matrix has six elements that</span>
0027 <span class="comment">% correspond to translation in X, Y and Z, and rotation about X, Y and</span>
0028 <span class="comment">% Z respectively.  The value should be 0 (for ignore) or 1.  The number</span>
0029 <span class="comment">% of non-zero elements should equal the number of manipulator DOF.</span>
0030 <span class="comment">%</span>
0031 <span class="comment">% Solution is computed iteratively using the pseudo-inverse of the</span>
0032 <span class="comment">% manipulator Jacobian.</span>
0033 <span class="comment">%</span>
0034 <span class="comment">% Such a solution is completely general, though much less efficient</span>
0035 <span class="comment">% than specific inverse kinematic solutions derived symbolically.</span>
0036 <span class="comment">%</span>
0037 <span class="comment">% This approach allows a solution to obtained at a singularity, but</span>
0038 <span class="comment">% the joint angles within the null space are arbitrarily assigned.</span>
0039 <span class="comment">%</span>
0040 <span class="comment">% For instance with a typical 5 DOF manipulator one would ignore</span>
0041 <span class="comment">% rotation about the wrist axis, that is, M = [1 1 1 1 1 0].</span>
0042 <span class="comment">%</span>
0043 <span class="comment">%</span>
0044 <span class="comment">% See also: FKINE, TR2DIFF, JACOB0, IKINE560.</span>
0045  
0046 <span class="comment">% Copyright (C) 1993-2002, by Peter I. Corke</span>
0047 
0048 <span class="comment">% MOD.HISTORY</span>
0049 <span class="comment">% 2/95    use new 2-argument version of tr2diff(), cleanup</span>
0050 <span class="comment">% 3/99    uses objects</span>
0051 <span class="comment">% 6/99    initialize qt before loop</span>
0052 <span class="comment">% 2/01    remove inv(base) xform, since it is included in fkine</span>
0053 <span class="comment">% 10/01    bug in mask for &lt;6 axes</span>
0054 <span class="comment">% $Log: ikine.m,v $</span>
0055 <span class="comment">% Revision 1.4  2002-04-14 10:15:41  pic</span>
0056 <span class="comment">% Fixed error message text.</span>
0057 <span class="comment">%</span>
0058 <span class="comment">% Revision 1.3  2002/04/01 11:47:13  pic</span>
0059 <span class="comment">% General cleanup of code: help comments, see also, copyright, remnant dh/dyn</span>
0060 <span class="comment">% references, clarification of functions.</span>
0061 <span class="comment">%</span>
0062 <span class="comment">% $Revision: 1.4 $</span>
0063 
0064 <a name="_sub0" href="#_subfunctions" class="code">function qt = ikine(robot, tr, q, m)</a>
0065     <span class="comment">%</span>
0066     <span class="comment">%  solution control parameters</span>
0067     <span class="comment">%</span>
0068     ilimit = 1000;
0069     stol = 1e-12;
0070 
0071     n = robot.n;
0072 
0073     <span class="keyword">if</span> nargin == 2,
0074         q = zeros(n, 1);
0075     <span class="keyword">else</span>
0076         q = q(:);
0077     <span class="keyword">end</span>
0078     <span class="keyword">if</span> nargin == 4,
0079         m = m(:);
0080         <span class="keyword">if</span> length(m) ~= 6,
0081             error(<span class="string">'Mask matrix should have 6 elements'</span>);
0082         <span class="keyword">end</span>
0083         <span class="keyword">if</span> length(find(m)) ~= robot.n 
0084             error(<span class="string">'Mask matrix must have same number of 1s as robot DOF'</span>)
0085         <span class="keyword">end</span>
0086     <span class="keyword">else</span>
0087         <span class="keyword">if</span> n &lt; 6,
0088             disp(<span class="string">'For a manipulator with fewer than 6DOF a mask matrix argument should be specified'</span>);
0089         <span class="keyword">end</span>
0090         m = ones(6, 1);
0091     <span class="keyword">end</span>
0092         
0093 
0094     tcount = 0;
0095     <span class="keyword">if</span> <a href="ishomog.html" class="code" title="function h = ishomog(tr)">ishomog</a>(tr),        <span class="comment">% single xform case</span>
0096         nm = 1;
0097         count = 0;
0098         <span class="keyword">while</span> nm &gt; stol,
0099             e = <a href="tr2diff.html" class="code" title="function d = tr2diff(t1, t2)">tr2diff</a>(<a href="fkine.html" class="code" title="function t = fkine(robot, q)">fkine</a>(robot, q'), tr) .* m;
0100             dq = pinv( <a href="jacob0.html" class="code" title="function J0 = jacob0(robot, q)">jacob0</a>(robot, q) ) * e;
0101             q = q + dq;
0102             nm = norm(dq);
0103             count = count+1;
0104             <span class="keyword">if</span> count &gt; ilimit,
0105                 error(<span class="string">'Solution wouldn''t converge'</span>)
0106             <span class="keyword">end</span>
0107         <span class="keyword">end</span>
0108         qt = q';
0109     <span class="keyword">else</span>            <span class="comment">% trajectory case</span>
0110         np = size(tr,3);
0111         qt = [];
0112         <span class="keyword">for</span> i=1:np
0113             nm = 1;
0114             T = tr(:,:,i);
0115             count = 0;
0116             <span class="keyword">while</span> nm &gt; stol,
0117                 e = <a href="tr2diff.html" class="code" title="function d = tr2diff(t1, t2)">tr2diff</a>(<a href="fkine.html" class="code" title="function t = fkine(robot, q)">fkine</a>(robot, q'), T) .* m;
0118                 dq = pinv( <a href="jacob0.html" class="code" title="function J0 = jacob0(robot, q)">jacob0</a>(robot, q) ) * e;
0119                 q = q + dq;
0120                 nm = norm(dq);
0121                 count = count+1;
0122                 <span class="keyword">if</span> count &gt; ilimit,
0123                     fprintf(<span class="string">'i=%d, nm=%f\n'</span>, i, nm);
0124                     error(<span class="string">'Solution wouldn''t converge'</span>)
0125                 <span class="keyword">end</span>
0126             <span class="keyword">end</span>
0127             qt = [qt; q'];
0128             tcount = tcount + count;
0129         <span class="keyword">end</span>
0130     <span class="keyword">end</span></pre></div>
<hr><address>Generated on Sun 18-May-2008 12:02:41 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/">m2html</a></strong> &copy; 2003</address>
</body>
</html>