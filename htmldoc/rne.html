<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of rne</title>
  <meta name="keywords" content="rne">
  <meta name="description" content="RNE	Compute inverse dynamics via recursive Newton-Euler formulation">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="./m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="./index.html">Home</a> &gt;  <a href="index.html">.</a> &gt; rne.m</div>

<!--<table width="100%"><tr><td align="left"><a href="./index.html"><img alt="<" border="0" src="./left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for .&nbsp;<img alt=">" border="0" src="./right.png"></a></td></tr></table>-->

<h1>rne
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="./up.png"></a></h2>
<div class="box"><strong>RNE	Compute inverse dynamics via recursive Newton-Euler formulation</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="./up.png"></a></h2>
<div class="box"><strong>function tau = rne(robot, a1, a2, a3, a4, a5) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="./up.png"></a></h2>
<div class="fragment"><pre class="comment">RNE    Compute inverse dynamics via recursive Newton-Euler formulation

    TAU = RNE(ROBOT, Q, QD, QDD)
    TAU = RNE(ROBOT, [Q QD QDD])

    Returns the joint torque required to achieve the specified joint position,
    velocity and acceleration state.

    Gravity vector is an attribute of the robot object but this may be 
    overriden by providing a gravity acceleration    vector [gx gy gz].

    TAU = RNE(ROBOT, Q, QD, QDD, GRAV)
    TAU = RNE(ROBOT, [Q QD QDD], GRAV)

    An external force/moment acting on the end of the manipulator may also be
    specified by a 6-element vector [Fx Fy Fz Mx My Mz].

    TAU = RNE(ROBOT, Q, QD, QDD, GRAV, FEXT)
    TAU = RNE(ROBOT, [Q QD QDD], GRAV, FEXT)

    where    Q, QD and QDD are row vectors of the manipulator state; pos, vel, and accel.

    The torque computed also contains a contribution due to armature
    inertia.

    See also ROBOT, FROBOT, <a href="accel.html" class="code" title="function qdd = accel(robot, Q, qd, torque)">ACCEL</a>, <a href="gravload.html" class="code" title="function tg = gravload(robot, q, grav)">GRAVLOAD</a>, <a href="inertia.html" class="code" title="function M = inertia(robot, q)">INERTIA</a>.

    Should be a MEX file.</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="./up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(./matlabicon.gif)">
<li><a href="numcols.html" class="code" title="function c = numcols(m)">numcols</a>	NUMCOLS Return number of columns in matrix</li><li><a href="numrows.html" class="code" title="function r = numrows(m)">numrows</a>	NUMROWS Return number of rows in matrix</li><li><a href="t2r.html" class="code" title="function R = tr2rot(T)">t2r</a>	TR2ROT Return rotational submatrix of a homogeneous transformation</li></ul>
This function is called by:
<ul style="list-style-image:url(./matlabicon.gif)">
<li><a href="accel.html" class="code" title="function qdd = accel(robot, Q, qd, torque)">accel</a>	ACCEL Compute manipulator forward dynamics</li><li><a href="coriolis.html" class="code" title="function c = coriolis(robot, q, qd)">coriolis</a>	CORIOLIS Compute the manipulator Coriolis matrix</li><li><a href="gravload.html" class="code" title="function tg = gravload(robot, q, grav)">gravload</a>	GRAVLOAD Compute the gravity loading on manipulator joints</li><li><a href="inertia.html" class="code" title="function M = inertia(robot, q)">inertia</a>	INERTIA Compute the manipulator inertia matrix</li><li><a href="itorque.html" class="code" title="function it = itorque(robot, q, qdd)">itorque</a>	ITORQUE Compute the manipulator inertia torque</li></ul>
<!-- crossreference -->


<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="./up.png"></a></h2>
<div class="fragment"><pre>0001 <span class="comment">%RNE    Compute inverse dynamics via recursive Newton-Euler formulation</span>
0002 <span class="comment">%</span>
0003 <span class="comment">%    TAU = RNE(ROBOT, Q, QD, QDD)</span>
0004 <span class="comment">%    TAU = RNE(ROBOT, [Q QD QDD])</span>
0005 <span class="comment">%</span>
0006 <span class="comment">%    Returns the joint torque required to achieve the specified joint position,</span>
0007 <span class="comment">%    velocity and acceleration state.</span>
0008 <span class="comment">%</span>
0009 <span class="comment">%    Gravity vector is an attribute of the robot object but this may be</span>
0010 <span class="comment">%    overriden by providing a gravity acceleration    vector [gx gy gz].</span>
0011 <span class="comment">%</span>
0012 <span class="comment">%    TAU = RNE(ROBOT, Q, QD, QDD, GRAV)</span>
0013 <span class="comment">%    TAU = RNE(ROBOT, [Q QD QDD], GRAV)</span>
0014 <span class="comment">%</span>
0015 <span class="comment">%    An external force/moment acting on the end of the manipulator may also be</span>
0016 <span class="comment">%    specified by a 6-element vector [Fx Fy Fz Mx My Mz].</span>
0017 <span class="comment">%</span>
0018 <span class="comment">%    TAU = RNE(ROBOT, Q, QD, QDD, GRAV, FEXT)</span>
0019 <span class="comment">%    TAU = RNE(ROBOT, [Q QD QDD], GRAV, FEXT)</span>
0020 <span class="comment">%</span>
0021 <span class="comment">%    where    Q, QD and QDD are row vectors of the manipulator state; pos, vel, and accel.</span>
0022 <span class="comment">%</span>
0023 <span class="comment">%    The torque computed also contains a contribution due to armature</span>
0024 <span class="comment">%    inertia.</span>
0025 <span class="comment">%</span>
0026 <span class="comment">%    See also ROBOT, FROBOT, ACCEL, GRAVLOAD, INERTIA.</span>
0027 <span class="comment">%</span>
0028 <span class="comment">%    Should be a MEX file.</span>
0029 
0030 <span class="comment">%</span>
0031 <span class="comment">% verified against MAPLE code, which is verified by examples</span>
0032 <span class="comment">%</span>
0033 
0034 <span class="comment">%    Copyright (C) 1992 Peter Corke</span>
0035 
0036 <span class="comment">% MOD.HISTORY</span>
0037 <span class="comment">%       6/95    make use of passed in FEXT</span>
0038 <span class="comment">%       4/95    fix bug in use of passed FEXT</span>
0039 <span class="comment">%    11/96    bug for prismatic case</span>
0040 <span class="comment">%    3/99    uses objects</span>
0041 <span class="comment">%</span>
0042 <span class="comment">%    Copyright (C) Peter Corke 1999</span>
0043 
0044 <a name="_sub0" href="#_subfunctions" class="code">function tau = rne(robot, a1, a2, a3, a4, a5)</a>
0045     <span class="keyword">if</span> robot.mdh ~= 0,
0046         error(<span class="string">'rne only valid for standard D&amp;H parameters'</span>)
0047     <span class="keyword">end</span>
0048 888
0049     z0 = [0;0;1];
0050     grav = robot.gravity;    <span class="comment">% default gravity from the object</span>
0051     fext = zeros(6, 1);
0052 
0053     n = robot.n;
0054     <span class="keyword">if</span> <a href="numcols.html" class="code" title="function c = numcols(m)">numcols</a>(a1) == 3*n,
0055         Q = a1(:,1:n);
0056         Qd = a1(:,n+1:2*n);
0057         Qdd = a1(:,2*n+1:3*n);
0058         np = <a href="numrows.html" class="code" title="function r = numrows(m)">numrows</a>(Q);
0059         <span class="keyword">if</span> nargin &gt;= 3,    
0060             grav = a2;
0061         <span class="keyword">end</span>
0062         <span class="keyword">if</span> nargin == 4,
0063             fext = a3;
0064         <span class="keyword">end</span>
0065     <span class="keyword">else</span>
0066         np = <a href="numrows.html" class="code" title="function r = numrows(m)">numrows</a>(a1);
0067         Q = a1;
0068         Qd = a2;
0069         Qdd = a3;
0070         <span class="keyword">if</span> <a href="numcols.html" class="code" title="function c = numcols(m)">numcols</a>(a1) ~= n | <a href="numcols.html" class="code" title="function c = numcols(m)">numcols</a>(Qd) ~= n | <a href="numcols.html" class="code" title="function c = numcols(m)">numcols</a>(Qdd) ~= n | <span class="keyword">...</span>
0071             <a href="numrows.html" class="code" title="function r = numrows(m)">numrows</a>(Qd) ~= np | <a href="numrows.html" class="code" title="function r = numrows(m)">numrows</a>(Qdd) ~= np,
0072             error(<span class="string">'bad data'</span>);
0073         <span class="keyword">end</span>
0074         <span class="keyword">if</span> nargin &gt;= 5,    
0075             grav = a4;
0076         <span class="keyword">end</span>
0077         <span class="keyword">if</span> nargin == 6,
0078             fext = a5;
0079         <span class="keyword">end</span>
0080     <span class="keyword">end</span>
0081     
0082     tau = zeros(np,n);
0083 
0084     <span class="keyword">for</span> p=1:np,        <span class="comment">% for all points on path</span>
0085         q = Q(p,:)';
0086         qd = Qd(p,:)';
0087         qdd = Qdd(p,:)';
0088     
0089         Fm = [];
0090         Nm = [];
0091         pstarm = [];
0092         Rm = [];
0093         w = zeros(3,1);
0094         wd = zeros(3,1);
0095         v = zeros(3,1);
0096         vd = grav;
0097 
0098     <span class="comment">%</span>
0099     <span class="comment">% init some variables, compute the link rotation matrices</span>
0100     <span class="comment">%</span>
0101         <span class="keyword">for</span> j=1:n,
0102             link = robot.link{j};
0103             Tj = link(q(j));
0104             <span class="keyword">if</span> link.RP == <span class="string">'R'</span>,
0105                 D = link.D;
0106             <span class="keyword">else</span>
0107                 D = q(j);
0108             <span class="keyword">end</span>
0109             alpha = link.alpha;
0110             pstarm(:,j) = [link.A; D*sin(alpha); D*cos(alpha)];
0111             <span class="keyword">if</span> j == 1,
0112                 robot.base
0113                 <span class="comment">%pstarm(:,j) = t2r(robot.base) * pstar(:,j);</span>
0114                 Tj = robot.base * Tj;
0115             <span class="keyword">end</span>
0116             Rm{j} = <a href="t2r.html" class="code" title="function R = tr2rot(T)">t2r</a>(Tj);
0117         <span class="keyword">end</span>
0118 
0119     <span class="comment">%</span>
0120     <span class="comment">%  the forward recursion</span>
0121     <span class="comment">%</span>
0122         <span class="keyword">for</span> j=1:n,
0123             link = robot.link{j};
0124 
0125             R = Rm{j}';
0126             pstar = pstarm(:,j);
0127             r = link.r;
0128 
0129             <span class="comment">%</span>
0130             <span class="comment">% statement order is important here</span>
0131             <span class="comment">%</span>
0132             <span class="keyword">if</span> link.RP == <span class="string">'R'</span>,
0133                 <span class="comment">% revolute axis</span>
0134                 wd = R*(wd + z0*qdd(j) + <span class="keyword">...</span>
0135                     cross(w,z0*qd(j)));
0136                 w = R*(w + z0*qd(j));
0137                 <span class="comment">%v = cross(w,pstar) + R*v;</span>
0138                 vd = cross(wd,pstar) + <span class="keyword">...</span>
0139                     cross(w, cross(w,pstar)) +R*vd;
0140 
0141             <span class="keyword">else</span>
0142                 <span class="comment">% prismatic axis</span>
0143                 w = R*w;
0144                 wd = R*wd;
0145                 vd = R*(z0*qdd(j)+vd) + <span class="keyword">...</span>
0146                     cross(wd,pstar) + <span class="keyword">...</span>
0147                     2*cross(w,R*z0*qd(j)) +<span class="keyword">...</span>
0148                     cross(w, cross(w,pstar));
0149             <span class="keyword">end</span>
0150 
0151             vhat = cross(wd,r) + <span class="keyword">...</span>
0152                 cross(w,cross(w,r)) + vd;
0153             F = link.m*vhat;
0154             N = link.I*wd + cross(w,link.I*w);
0155             Fm = [Fm F];
0156             Nm = [Nm N];
0157         <span class="keyword">end</span>
0158 
0159     <span class="comment">%</span>
0160     <span class="comment">%  the backward recursion</span>
0161     <span class="comment">%</span>
0162 
0163         f = fext(1:3);        <span class="comment">% force/moments on end of arm</span>
0164         nn = fext(4:6);
0165 
0166         <span class="keyword">for</span> j=n:-1:1,
0167             link = robot.link{j};
0168             pstar = pstarm(:,j);
0169             
0170             <span class="comment">%</span>
0171             <span class="comment">% order of these statements is important, since both</span>
0172             <span class="comment">% nn and f are functions of previous f.</span>
0173             <span class="comment">%</span>
0174             <span class="keyword">if</span> j == n,
0175                 R = eye(3,3);
0176             <span class="keyword">else</span>
0177                 R = Rm{j+1};
0178             <span class="keyword">end</span>
0179             r = link.r;
0180             nn = R*(nn + cross(R'*pstar,f)) + <span class="keyword">...</span>
0181                 cross(pstar+r,Fm(:,j)) + <span class="keyword">...</span>
0182                 Nm(:,j);
0183             f = R*f + Fm(:,j);
0184             R = Rm{j};
0185             <span class="keyword">if</span> link.RP == <span class="string">'R'</span>,
0186                 <span class="comment">% revolute</span>
0187                 tau(p,j) = nn'*(R'*z0) + <span class="keyword">...</span>
0188                     link.G^2 * ( link.Jm*qdd(j) + <span class="keyword">...</span>
0189                         friction(link, qd(j)) <span class="keyword">...</span>
0190                     );
0191             <span class="keyword">else</span>
0192                 <span class="comment">% prismatic</span>
0193                 tau(p,j) = f'*(R'*z0) + <span class="keyword">...</span>
0194                     link.G^2 * ( link.Jm*qdd(j) + <span class="keyword">...</span>
0195                         friction(link, qd(j)) <span class="keyword">...</span>
0196                     );
0197             <span class="keyword">end</span>
0198         <span class="keyword">end</span>
0199     <span class="keyword">end</span></pre></div>
<hr><address>Generated on Sun 18-May-2008 12:02:41 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/">m2html</a></strong> &copy; 2003</address>
</body>
</html>