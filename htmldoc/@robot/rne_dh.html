<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of rne_dh</title>
  <meta name="keywords" content="rne_dh">
  <meta name="description" content="RNE_DH Compute inverse dynamics via recursive Newton-Euler formulation">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../index.html">Home</a> &gt;  <a href="#">@robot</a> &gt; rne_dh.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../index.html"><img alt="<" border="0" src="../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for ./@robot&nbsp;<img alt=">" border="0" src="../right.png"></a></td></tr></table>-->

<h1>rne_dh
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>RNE_DH Compute inverse dynamics via recursive Newton-Euler formulation</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function tau = rne_dh(robot, a1, a2, a3, a4, a5) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment">RNE_DH Compute inverse dynamics via recursive Newton-Euler formulation

    TAU = RNE(ROBOT, Q, QD, QDD)
    TAU = RNE(ROBOT, [Q QD QDD])

 Returns the joint torque required to achieve the specified joint position,
 velocity and acceleration state.

 Gravity vector is an attribute of the robot object but this may be 
 overriden by providing a gravity acceleration vector [gx gy gz].

    TAU = RNE(ROBOT, Q, QD, QDD, GRAV)
    TAU = RNE(ROBOT, [Q QD QDD], GRAV)

 An external force/moment acting on the end of the manipulator may also be
 specified by a 6-element vector [Fx Fy Fz Mx My Mz].

    TAU = RNE(ROBOT, Q, QD, QDD, GRAV, FEXT)
    TAU = RNE(ROBOT, [Q QD QDD], GRAV, FEXT)

 where Q, QD and QDD are row vectors of the manipulator state; pos, vel, 
 and accel.

 The torque computed also contains a contribution due to armature
 inertia.

 RNE can be either an M-file or a MEX-file.  See the manual for details on
 how to configure the MEX-file.  The M-file is a wrapper which calls either
 RNE_DH or RNE_MDH depending on the kinematic conventions used by the robot
 object.

 See also: <a href="robot.html" class="code" title="function r = robot(L, a1, a2, a3)">ROBOT</a>, ACCEL, GRAVLOAD, INERTIA.</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="friction.html" class="code" title="function  tau = friction(robot, qd)">friction</a>	FRICTION Compute friction torque for a ROBOT object</li></ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="rne.html" class="code" title="function tau = rne(robot, varargin)">rne</a>	RNE Compute inverse dynamics via recursive Newton-Euler formulation</li></ul>
<!-- crossreference -->


<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <span class="comment">%RNE_DH Compute inverse dynamics via recursive Newton-Euler formulation</span>
0002 <span class="comment">%</span>
0003 <span class="comment">%    TAU = RNE(ROBOT, Q, QD, QDD)</span>
0004 <span class="comment">%    TAU = RNE(ROBOT, [Q QD QDD])</span>
0005 <span class="comment">%</span>
0006 <span class="comment">% Returns the joint torque required to achieve the specified joint position,</span>
0007 <span class="comment">% velocity and acceleration state.</span>
0008 <span class="comment">%</span>
0009 <span class="comment">% Gravity vector is an attribute of the robot object but this may be</span>
0010 <span class="comment">% overriden by providing a gravity acceleration vector [gx gy gz].</span>
0011 <span class="comment">%</span>
0012 <span class="comment">%    TAU = RNE(ROBOT, Q, QD, QDD, GRAV)</span>
0013 <span class="comment">%    TAU = RNE(ROBOT, [Q QD QDD], GRAV)</span>
0014 <span class="comment">%</span>
0015 <span class="comment">% An external force/moment acting on the end of the manipulator may also be</span>
0016 <span class="comment">% specified by a 6-element vector [Fx Fy Fz Mx My Mz].</span>
0017 <span class="comment">%</span>
0018 <span class="comment">%    TAU = RNE(ROBOT, Q, QD, QDD, GRAV, FEXT)</span>
0019 <span class="comment">%    TAU = RNE(ROBOT, [Q QD QDD], GRAV, FEXT)</span>
0020 <span class="comment">%</span>
0021 <span class="comment">% where Q, QD and QDD are row vectors of the manipulator state; pos, vel,</span>
0022 <span class="comment">% and accel.</span>
0023 <span class="comment">%</span>
0024 <span class="comment">% The torque computed also contains a contribution due to armature</span>
0025 <span class="comment">% inertia.</span>
0026 <span class="comment">%</span>
0027 <span class="comment">% RNE can be either an M-file or a MEX-file.  See the manual for details on</span>
0028 <span class="comment">% how to configure the MEX-file.  The M-file is a wrapper which calls either</span>
0029 <span class="comment">% RNE_DH or RNE_MDH depending on the kinematic conventions used by the robot</span>
0030 <span class="comment">% object.</span>
0031 <span class="comment">%</span>
0032 <span class="comment">% See also: ROBOT, ACCEL, GRAVLOAD, INERTIA.</span>
0033 
0034 <span class="comment">%</span>
0035 <span class="comment">% verified against MAPLE code, which is verified by examples</span>
0036 <span class="comment">%</span>
0037 
0038 <span class="comment">% Copyright (C) 1992-2002, by Peter I. Corke</span>
0039 
0040 <span class="comment">% MOD.HISTORY</span>
0041 <span class="comment">%       6/95    make use of passed in FEXT</span>
0042 <span class="comment">%       4/95    fix bug in use of passed FEXT</span>
0043 <span class="comment">% 11/96    bug for prismatic case</span>
0044 <span class="comment">% 3/99    uses objects</span>
0045 <span class="comment">% $Log: rne_dh.m,v $</span>
0046 <span class="comment">% Revision 1.5  2007-01-21 06:24:55  cor134</span>
0047 <span class="comment">% Added support for base transform.</span>
0048 <span class="comment">%</span>
0049 <span class="comment">% Revision 1.4  2002/09/11 04:53:43  pic</span>
0050 <span class="comment">% Fixed bug with gear ratio and friction.</span>
0051 <span class="comment">%</span>
0052 <span class="comment">% Revision 1.3  2002/04/02 11:24:40  pic</span>
0053 <span class="comment">% Updated comment blocks, fix function names.</span>
0054 <span class="comment">%</span>
0055 <span class="comment">% $Revision: 1.5 $</span>
0056 
0057 <a name="_sub0" href="#_subfunctions" class="code">function tau = rne_dh(robot, a1, a2, a3, a4, a5)</a>
0058 
0059     z0 = [0;0;1];
0060     grav = robot.gravity;    <span class="comment">% default gravity from the object</span>
0061     fext = zeros(6, 1);
0062 
0063     <span class="comment">% Set debug to:</span>
0064     <span class="comment">%    0 no messages</span>
0065     <span class="comment">%    1 display results of forward and backward recursions</span>
0066     <span class="comment">%    2 display print R and p*</span>
0067     debug = 0;
0068 
0069     n = robot.n;
0070     <span class="keyword">if</span> numcols(a1) == 3*n,
0071         Q = a1(:,1:n);
0072         Qd = a1(:,n+1:2*n);
0073         Qdd = a1(:,2*n+1:3*n);
0074         np = numrows(Q);
0075         <span class="keyword">if</span> nargin &gt;= 3,    
0076             grav = a2(:);
0077         <span class="keyword">end</span>
0078         <span class="keyword">if</span> nargin == 4,
0079             fext = a3;
0080         <span class="keyword">end</span>
0081     <span class="keyword">else</span>
0082         np = numrows(a1);
0083         Q = a1;
0084         Qd = a2;
0085         Qdd = a3;
0086         <span class="keyword">if</span> numcols(a1) ~= n | numcols(Qd) ~= n | numcols(Qdd) ~= n | <span class="keyword">...</span>
0087             numrows(Qd) ~= np | numrows(Qdd) ~= np,
0088             error(<span class="string">'bad data'</span>);
0089         <span class="keyword">end</span>
0090         <span class="keyword">if</span> nargin &gt;= 5,    
0091             grav = a4(:);
0092         <span class="keyword">end</span>
0093         <span class="keyword">if</span> nargin == 6,
0094             fext = a5;
0095         <span class="keyword">end</span>
0096     <span class="keyword">end</span>
0097     
0098     tau = zeros(np,n);
0099 
0100     <span class="keyword">for</span> p=1:np,
0101         q = Q(p,:)';
0102         qd = Qd(p,:)';
0103         qdd = Qdd(p,:)';
0104     
0105         Fm = [];
0106         Nm = [];
0107         pstarm = [];
0108         Rm = [];
0109         w = zeros(3,1);
0110         wd = zeros(3,1);
0111         v = zeros(3,1);
0112         vd = grav(:);
0113 
0114     <span class="comment">%</span>
0115     <span class="comment">% init some variables, compute the link rotation matrices</span>
0116     <span class="comment">%</span>
0117         <span class="keyword">for</span> j=1:n,
0118             link = robot.link{j};
0119             Tj = link(q(j));
0120             <span class="keyword">if</span> link.RP == <span class="string">'R'</span>,
0121                 D = link.D;
0122             <span class="keyword">else</span>
0123                 D = q(j);
0124             <span class="keyword">end</span>
0125             alpha = link.alpha;
0126             pstar = [link.A; D*sin(alpha); D*cos(alpha)];
0127             <span class="keyword">if</span> j == 1,
0128                 pstar = t2r(robot.base) * pstar;
0129                 Tj = robot.base * Tj;
0130             <span class="keyword">end</span>
0131             pstarm(:,j) = pstar;
0132             Rm{j} = tr2rot(Tj);
0133             <span class="keyword">if</span> debug&gt;1,
0134                 Rm{j}
0135                 Pstarm(:,j)'
0136             <span class="keyword">end</span>
0137         <span class="keyword">end</span>
0138 
0139     <span class="comment">%</span>
0140     <span class="comment">%  the forward recursion</span>
0141     <span class="comment">%</span>
0142         <span class="keyword">for</span> j=1:n,
0143             link = robot.link{j};
0144 
0145             Rt = Rm{j}';    <span class="comment">% transpose!!</span>
0146             pstar = pstarm(:,j);
0147             r = link.r;
0148 
0149             <span class="comment">%</span>
0150             <span class="comment">% statement order is important here</span>
0151             <span class="comment">%</span>
0152             <span class="keyword">if</span> link.RP == <span class="string">'R'</span>,
0153                 <span class="comment">% revolute axis</span>
0154                 wd = Rt*(wd + z0*qdd(j) + <span class="keyword">...</span>
0155                     cross(w,z0*qd(j)));
0156                 w = Rt*(w + z0*qd(j));
0157                 <span class="comment">%v = cross(w,pstar) + Rt*v;</span>
0158                 vd = cross(wd,pstar) + <span class="keyword">...</span>
0159                     cross(w, cross(w,pstar)) +Rt*vd;
0160 
0161             <span class="keyword">else</span>
0162                 <span class="comment">% prismatic axis</span>
0163                 w = Rt*w;
0164                 wd = Rt*wd;
0165                 vd = Rt*(z0*qdd(j)+vd) + <span class="keyword">...</span>
0166                     cross(wd,pstar) + <span class="keyword">...</span>
0167                     2*cross(w,Rt*z0*qd(j)) +<span class="keyword">...</span>
0168                     cross(w, cross(w,pstar));
0169             <span class="keyword">end</span>
0170 
0171             vhat = cross(wd,r) + <span class="keyword">...</span>
0172                 cross(w,cross(w,r)) + vd;
0173             F = link.m*vhat;
0174             N = link.I*wd + cross(w,link.I*w);
0175             Fm = [Fm F];
0176             Nm = [Nm N];
0177 
0178             <span class="keyword">if</span> debug,
0179                 fprintf(<span class="string">'w: '</span>); fprintf(<span class="string">'%.3f '</span>, w)
0180                 fprintf(<span class="string">'\nwd: '</span>); fprintf(<span class="string">'%.3f '</span>, wd)
0181                 fprintf(<span class="string">'\nvd: '</span>); fprintf(<span class="string">'%.3f '</span>, vd)
0182                 fprintf(<span class="string">'\nvdbar: '</span>); fprintf(<span class="string">'%.3f '</span>, vhat)
0183                 fprintf(<span class="string">'\n'</span>);
0184             <span class="keyword">end</span>
0185         <span class="keyword">end</span>
0186 
0187     <span class="comment">%</span>
0188     <span class="comment">%  the backward recursion</span>
0189     <span class="comment">%</span>
0190 
0191         fext = fext(:);
0192         f = fext(1:3);        <span class="comment">% force/moments on end of arm</span>
0193         nn = fext(4:6);
0194 
0195         <span class="keyword">for</span> j=n:-1:1,
0196             link = robot.link{j};
0197             pstar = pstarm(:,j);
0198             
0199             <span class="comment">%</span>
0200             <span class="comment">% order of these statements is important, since both</span>
0201             <span class="comment">% nn and f are functions of previous f.</span>
0202             <span class="comment">%</span>
0203             <span class="keyword">if</span> j == n,
0204                 R = eye(3,3);
0205             <span class="keyword">else</span>
0206                 R = Rm{j+1};
0207             <span class="keyword">end</span>
0208             r = link.r;
0209             nn = R*(nn + cross(R'*pstar,f)) + <span class="keyword">...</span>
0210                 cross(pstar+r,Fm(:,j)) + <span class="keyword">...</span>
0211                 Nm(:,j);
0212             f = R*f + Fm(:,j);
0213             <span class="keyword">if</span> debug,
0214                 fprintf(<span class="string">'f: '</span>); fprintf(<span class="string">'%.3f '</span>, f)
0215                 fprintf(<span class="string">'\nn: '</span>); fprintf(<span class="string">'%.3f '</span>, nn)
0216                 fprintf(<span class="string">'\n'</span>);
0217             <span class="keyword">end</span>
0218 
0219             R = Rm{j};
0220             <span class="keyword">if</span> link.RP == <span class="string">'R'</span>,
0221                 <span class="comment">% revolute</span>
0222                 tau(p,j) = nn'*(R'*z0) + <span class="keyword">...</span>
0223                     link.G^2 * link.Jm*qdd(j) + <span class="keyword">...</span>
0224                     link.G * <a href="friction.html" class="code" title="function  tau = friction(robot, qd)">friction</a>(link, qd(j));
0225             <span class="keyword">else</span>
0226                 <span class="comment">% prismatic</span>
0227                 tau(p,j) = f'*(R'*z0) + <span class="keyword">...</span>
0228                     link.G^2 * link.Jm*qdd(j) + <span class="keyword">...</span>
0229                     link.G * <a href="friction.html" class="code" title="function  tau = friction(robot, qd)">friction</a>(link, qd(j));
0230             <span class="keyword">end</span>
0231         <span class="keyword">end</span>
0232     <span class="keyword">end</span></pre></div>
<hr><address>Generated on Sun 18-May-2008 12:02:41 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/">m2html</a></strong> &copy; 2003</address>
</body>
</html>