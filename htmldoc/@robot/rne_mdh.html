<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of rne_mdh</title>
  <meta name="keywords" content="rne_mdh">
  <meta name="description" content="RNE_MDH Compute inverse dynamics via recursive Newton-Euler formulation">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../index.html">Home</a> &gt;  <a href="#">@robot</a> &gt; rne_mdh.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../index.html"><img alt="<" border="0" src="../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for ./@robot&nbsp;<img alt=">" border="0" src="../right.png"></a></td></tr></table>-->

<h1>rne_mdh
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>RNE_MDH Compute inverse dynamics via recursive Newton-Euler formulation</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function tau = rne_mdh(robot, a1, a2, a3, a4, a5) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment">RNE_MDH Compute inverse dynamics via recursive Newton-Euler formulation

    TAU = RNE(ROBOT, Q, QD, QDD)
    TAU = RNE(ROBOT, [Q QD QDD])

 Returns the joint torque required to achieve the specified joint position,
 velocity and acceleration state.

 Gravity vector is an attribute of the robot object but this may be 
 overriden by providing a gravity acceleration vector [gx gy gz].

    TAU = RNE(ROBOT, Q, QD, QDD, GRAV)
    TAU = RNE(ROBOT, [Q QD QDD], GRAV)

 An external force/moment acting on the end of the manipulator may also be
 specified by a 6-element vector [Fx Fy Fz Mx My Mz].

    TAU = RNE(ROBOT, Q, QD, QDD, GRAV, FEXT)
    TAU = RNE(ROBOT, [Q QD QDD], GRAV, FEXT)

 where Q, QD and QDD are row vectors of the manipulator state; pos, vel, 
 and accel.

 The torque computed also contains a contribution due to armature
 inertia.

 RNE can be either an M-file or a MEX-file.  See the manual for details on
 how to configure the MEX-file.  The M-file is a wrapper which calls either
 RNE_DH or RNE_MDH depending on the kinematic conventions used by the robot
 object.

 See also: <a href="robot.html" class="code" title="function r = robot(L, a1, a2, a3)">ROBOT</a>, ACCEL, GRAVLOAD, INERTIA.</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="friction.html" class="code" title="function  tau = friction(robot, qd)">friction</a>	FRICTION Compute friction torque for a ROBOT object</li></ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="rne.html" class="code" title="function tau = rne(robot, varargin)">rne</a>	RNE Compute inverse dynamics via recursive Newton-Euler formulation</li></ul>
<!-- crossreference -->


<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <span class="comment">%RNE_MDH Compute inverse dynamics via recursive Newton-Euler formulation</span>
0002 <span class="comment">%</span>
0003 <span class="comment">%    TAU = RNE(ROBOT, Q, QD, QDD)</span>
0004 <span class="comment">%    TAU = RNE(ROBOT, [Q QD QDD])</span>
0005 <span class="comment">%</span>
0006 <span class="comment">% Returns the joint torque required to achieve the specified joint position,</span>
0007 <span class="comment">% velocity and acceleration state.</span>
0008 <span class="comment">%</span>
0009 <span class="comment">% Gravity vector is an attribute of the robot object but this may be</span>
0010 <span class="comment">% overriden by providing a gravity acceleration vector [gx gy gz].</span>
0011 <span class="comment">%</span>
0012 <span class="comment">%    TAU = RNE(ROBOT, Q, QD, QDD, GRAV)</span>
0013 <span class="comment">%    TAU = RNE(ROBOT, [Q QD QDD], GRAV)</span>
0014 <span class="comment">%</span>
0015 <span class="comment">% An external force/moment acting on the end of the manipulator may also be</span>
0016 <span class="comment">% specified by a 6-element vector [Fx Fy Fz Mx My Mz].</span>
0017 <span class="comment">%</span>
0018 <span class="comment">%    TAU = RNE(ROBOT, Q, QD, QDD, GRAV, FEXT)</span>
0019 <span class="comment">%    TAU = RNE(ROBOT, [Q QD QDD], GRAV, FEXT)</span>
0020 <span class="comment">%</span>
0021 <span class="comment">% where Q, QD and QDD are row vectors of the manipulator state; pos, vel,</span>
0022 <span class="comment">% and accel.</span>
0023 <span class="comment">%</span>
0024 <span class="comment">% The torque computed also contains a contribution due to armature</span>
0025 <span class="comment">% inertia.</span>
0026 <span class="comment">%</span>
0027 <span class="comment">% RNE can be either an M-file or a MEX-file.  See the manual for details on</span>
0028 <span class="comment">% how to configure the MEX-file.  The M-file is a wrapper which calls either</span>
0029 <span class="comment">% RNE_DH or RNE_MDH depending on the kinematic conventions used by the robot</span>
0030 <span class="comment">% object.</span>
0031 <span class="comment">%</span>
0032 <span class="comment">% See also: ROBOT, ACCEL, GRAVLOAD, INERTIA.</span>
0033 <span class="comment">%</span>
0034 
0035 <span class="comment">% Copyright (C) 1995-2002, by Peter I. Corke</span>
0036 
0037 
0038 <span class="comment">% MOD.HISTORY</span>
0039 <span class="comment">%       6/95    make use of passed in FEXT</span>
0040 <span class="comment">%       4/95    fix bug in use of passed FEXT</span>
0041 <span class="comment">% 11/96    bug for prismatic case</span>
0042 <span class="comment">% 3/99    uses objects</span>
0043 <span class="comment">% $Log: rne_mdh.m,v $</span>
0044 <span class="comment">% Revision 1.5  2007-01-21 06:24:55  cor134</span>
0045 <span class="comment">% Added support for base transform.</span>
0046 <span class="comment">%</span>
0047 <span class="comment">% Revision 1.4  2002/09/11 04:53:43  pic</span>
0048 <span class="comment">% Fixed bug with gear ratio and friction.</span>
0049 <span class="comment">%</span>
0050 <span class="comment">% Revision 1.3  2002/04/02 11:24:40  pic</span>
0051 <span class="comment">% Updated comment blocks, fix function names.</span>
0052 <span class="comment">%</span>
0053 <span class="comment">% $Revision: 1.5 $</span>
0054 <span class="comment">%</span>
0055 
0056 <a name="_sub0" href="#_subfunctions" class="code">function tau = rne_mdh(robot, a1, a2, a3, a4, a5)</a>
0057 
0058     z0 = [0;0;1];
0059     grav = robot.gravity;    <span class="comment">% default gravity from the object</span>
0060     fext = zeros(6, 1);
0061 
0062     <span class="comment">% Set debug to:</span>
0063     <span class="comment">%    0 no messages</span>
0064     <span class="comment">%    1 display results of forward and backward recursions</span>
0065     <span class="comment">%    2 display print R and p*</span>
0066     debug = 0;
0067 
0068     n = robot.n;
0069     <span class="keyword">if</span> numcols(a1) == 3*n,
0070         Q = a1(:,1:n);
0071         Qd = a1(:,n+1:2*n);
0072         Qdd = a1(:,2*n+1:3*n);
0073         np = numrows(Q);
0074         <span class="keyword">if</span> nargin &gt;= 3,    
0075             grav = a2(:);
0076         <span class="keyword">end</span>
0077         <span class="keyword">if</span> nargin == 4,
0078             fext = a3;
0079         <span class="keyword">end</span>
0080     <span class="keyword">else</span>
0081         np = numrows(a1);
0082         Q = a1;
0083         Qd = a2;
0084         Qdd = a3;
0085         <span class="keyword">if</span> numcols(a1) ~= n | numcols(Qd) ~= n | numcols(Qdd) ~= n | <span class="keyword">...</span>
0086             numrows(Qd) ~= np | numrows(Qdd) ~= np,
0087             error(<span class="string">'bad data'</span>);
0088         <span class="keyword">end</span>
0089         <span class="keyword">if</span> nargin &gt;= 5,    
0090             grav = a4(:);
0091         <span class="keyword">end</span>
0092         <span class="keyword">if</span> nargin == 6,
0093             fext = a5;
0094         <span class="keyword">end</span>
0095     <span class="keyword">end</span>
0096     
0097     tau = zeros(np,n);
0098 
0099     <span class="keyword">for</span> p=1:np,
0100         q = Q(p,:)';
0101         qd = Qd(p,:)';
0102         qdd = Qdd(p,:)';
0103     
0104         Fm = [];
0105         Nm = [];
0106         pstarm = [];
0107         Rm = [];
0108         w = zeros(3,1);
0109         wd = zeros(3,1);
0110         v = zeros(3,1);
0111         vd = grav(:);
0112 
0113     <span class="comment">%</span>
0114     <span class="comment">% init some variables, compute the link rotation matrices</span>
0115     <span class="comment">%</span>
0116         <span class="keyword">for</span> j=1:n,
0117             link = robot.link{j};
0118             Tj = link(q(j));
0119             <span class="keyword">if</span> link.RP == <span class="string">'R'</span>,
0120                 D = link.D;
0121             <span class="keyword">else</span>
0122                 D = q(j);
0123             <span class="keyword">end</span>
0124             alpha = link.alpha;
0125             pm = [link.A; -D*sin(alpha); D*cos(alpha)];    <span class="comment">% (i-1) P i</span>
0126             <span class="keyword">if</span> j == 1,
0127                 pm = t2r(robot.base) * pm;
0128                 Tj = robot.base * Tj;
0129             <span class="keyword">end</span>
0130             Pm(:,j) = pm;
0131             Rm{j} = tr2rot(Tj);
0132             <span class="keyword">if</span> debug&gt;1,
0133                 Rm{j}
0134                 Pm(:,j)'
0135             <span class="keyword">end</span>
0136         <span class="keyword">end</span>
0137 
0138     <span class="comment">%</span>
0139     <span class="comment">%  the forward recursion</span>
0140     <span class="comment">%</span>
0141         <span class="keyword">for</span> j=1:n,
0142             link = robot.link{j};
0143 
0144             R = Rm{j}';    <span class="comment">% transpose!!</span>
0145             P = Pm(:,j);
0146             Pc = link.r;
0147 
0148             <span class="comment">%</span>
0149             <span class="comment">% trailing underscore means new value</span>
0150             <span class="comment">%</span>
0151             <span class="keyword">if</span> link.RP == <span class="string">'R'</span>,
0152                 <span class="comment">% revolute axis</span>
0153                 w_ = R*w + z0*qd(j);
0154                 wd_ = R*wd + cross(R*w,z0*qd(j)) + z0*qdd(j);
0155                 <span class="comment">%v = cross(w,P) + R*v;</span>
0156                 vd_ = R * (cross(wd,P) + <span class="keyword">...</span>
0157                     cross(w, cross(w,P)) + vd);
0158 
0159             <span class="keyword">else</span>
0160                 <span class="comment">% prismatic axis</span>
0161                 w_ = R*w;
0162                 wd_ = R*wd;
0163                 <span class="comment">%v = R*(z0*qd(j) + v) + cross(w,P);</span>
0164                 vd_ = R*(cross(wd,P) + <span class="keyword">...</span>
0165                     cross(w, cross(w,P)) + vd <span class="keyword">...</span>
0166                       ) + 2*cross(R*w,z0*qd(j)) + z0*qdd(j);
0167             <span class="keyword">end</span>
0168             <span class="comment">% update variables</span>
0169             w = w_;
0170             wd = wd_;
0171             vd = vd_;
0172 
0173             vdC = cross(wd,Pc) + <span class="keyword">...</span>
0174                 cross(w,cross(w,Pc)) + vd;
0175             F = link.m*vdC;
0176             N = link.I*wd + cross(w,link.I*w);
0177             Fm = [Fm F];
0178             Nm = [Nm N];
0179             <span class="keyword">if</span> debug,
0180                 fprintf(<span class="string">'w: '</span>); fprintf(<span class="string">'%.3f '</span>, w)
0181                 fprintf(<span class="string">'\nwd: '</span>); fprintf(<span class="string">'%.3f '</span>, wd)
0182                 fprintf(<span class="string">'\nvd: '</span>); fprintf(<span class="string">'%.3f '</span>, vd)
0183                 fprintf(<span class="string">'\nvdbar: '</span>); fprintf(<span class="string">'%.3f '</span>, vdC)
0184                 fprintf(<span class="string">'\n'</span>);
0185             <span class="keyword">end</span>
0186         <span class="keyword">end</span>
0187 
0188     <span class="comment">%</span>
0189     <span class="comment">%  the backward recursion</span>
0190     <span class="comment">%</span>
0191 
0192         fext = fext(:);
0193         f = fext(1:3);        <span class="comment">% force/moments on end of arm</span>
0194         nn = fext(4:6);
0195 
0196         <span class="keyword">for</span> j=n:-1:1,
0197             
0198             <span class="comment">%</span>
0199             <span class="comment">% order of these statements is important, since both</span>
0200             <span class="comment">% nn and f are functions of previous f.</span>
0201             <span class="comment">%</span>
0202             link = robot.link{j};
0203             
0204             <span class="keyword">if</span> j == n,
0205                 R = eye(3,3);
0206                 P = [0;0;0];
0207             <span class="keyword">else</span>
0208                 R = Rm{j+1};
0209                 P = Pm(:,j+1);        <span class="comment">% i/P/(i+1)</span>
0210             <span class="keyword">end</span>
0211             Pc = link.r;
0212             
0213             f_ = R*f + Fm(:,j);
0214             nn_ = Nm(:,j) + R*nn + cross(Pc,Fm(:,j)) + <span class="keyword">...</span>
0215                 cross(P,R*f);
0216             
0217             f = f_;
0218             nn = nn_;
0219 
0220             <span class="keyword">if</span> debug,
0221                 fprintf(<span class="string">'f: '</span>); fprintf(<span class="string">'%.3f '</span>, f)
0222                 fprintf(<span class="string">'\nn: '</span>); fprintf(<span class="string">'%.3f '</span>, nn)
0223                 fprintf(<span class="string">'\n'</span>);
0224             <span class="keyword">end</span>
0225             <span class="keyword">if</span> link.RP == <span class="string">'R'</span>,
0226                 <span class="comment">% revolute</span>
0227                 tau(p,j) = nn'*z0 + <span class="keyword">...</span>
0228                     link.G^2 * link.Jm*qdd(j) + <span class="keyword">...</span>
0229                     link.G * <a href="friction.html" class="code" title="function  tau = friction(robot, qd)">friction</a>(link, qd(j));
0230             <span class="keyword">else</span>
0231                 <span class="comment">% prismatic</span>
0232                 tau(p,j) = f'*z0 + <span class="keyword">...</span>
0233                     link.G^2 * link.Jm*qdd(j) + <span class="keyword">...</span>
0234                     link.G * <a href="friction.html" class="code" title="function  tau = friction(robot, qd)">friction</a>(link, qd(j));
0235             <span class="keyword">end</span>
0236         <span class="keyword">end</span>
0237     <span class="keyword">end</span></pre></div>
<hr><address>Generated on Sun 18-May-2008 12:02:41 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/">m2html</a></strong> &copy; 2003</address>
</body>
</html>